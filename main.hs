{- proph - A simple resolution-based theorem prover for propositional logic. -}

module Main where
import System.Environment
import Parser
import Resolve
import Data.List

a = Var "A"
b = Var "B"
c = Var "C"
d = Var "D"

u = Dis a (Dis b c)
v = Dis (Neg a) (Dis b c)

ul = flattenDis u
vl = flattenDis v

isQuery :: Term -> Bool
isQuery (Query _) = True
isQuery _ = False

{-|
   Okay, things look pretty good so far!

   Next up:

        1. Improve the parser. It handles errors in a dangerous way right now.
        Also, it's got a very restrictive syntax. We should adopt Prolog's
        period terminator, I think.

            1.1. Improve the parsing itself.
            1.2. Improve error handling.

        2. Improve our resolution algorithm implementation. Right now we just
        try every possible combination, which is easy to write, but terribly
        inefficient. We should do a proper search algorithm.

        3. Store the steps taken to resolution, then be able to print it out.
        In other words, I want an autogenerated, Zeilberger-esque, "PROOF THAT
        CLAUSES ENTAIL QUERY" message to come out. Possibly find the *shortest*
        such proof, but that might be asking for too much of me right now.

        4. Implement a REPL.
-}

handleStatements :: [Term] -> IO ()
handleStatements statements = do
    let (queries, clauses) = partition isQuery statements
        cnfClauses = clausesToCNF clauses
        trueQueries = filter (clausesEntail cnfClauses) queries
    putStrLn "Clauses:"
    print cnfClauses
    putStrLn "Queries:"
    print queries
    putStrLn "Queries that follow:"
    mapM_ print trueQueries

main = do
    (path:_) <- getArgs
    contents <- readFile path
    case parseInput contents of
      Left err -> print err
      Right statements -> handleStatements statements
